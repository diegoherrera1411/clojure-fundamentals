# Even Fibonacci numbers

> Each new term in the Fibonacci sequence is generated by adding the previous two terms.
> By starting with 1 and 2, the first 10 terms will be
> 
> **1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...**
> 
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
> find the sum of the even-valued terms.

## My Solution

Computing the nth Fibonacci number is a common problem posed in most programming courses.
It helps illustrating recursion, and it has am easy, yet naive, implementation. But this
implementation is not enough! Since Fibonacci numbers grow exponentially fast in size, the
naive algorithm slows down dramatically (and may cause stack overflow) for computing just 
the 100th Fibonacci number.

> To compute large Fibonacci numbers, the solution should cache the Fibonacci numbers
> involved in the recursion at each step

Since Clojure requires _tail recursion_ (i.e. that the last call of the recursive function
is to the function itself) in order to apply memory optimizations, my first solution for
computing Fibonacci numbers was something like this

```clojure
(defn next-fibonacci-term [fib-seq]
  (->> fib-seq
       (take-last 2)
       (reduce +)))

(defn fibonacci-number
  ([n] (fibonacci-number (bigint n) [1 1]))
  ([n fb-seq]
   (if (<= n (count fb-seq))
     (last fb-seq)
     (recur n (conj fb-seq (next-fibonacci-term fb-seq))))))
```

This wasn't too bad, and after filtering the even numbers below four million, I obtained Project
Euler's approval. However, I came across a 
[really interesting solution in StackOverflow](https://stackoverflow.com/questions/8939970/a-recursive-fibonacci-function-in-clojure)
This solution is awesome since it uses the `iter` function, which returns a lazy sequence that results
from successive application of a function to an initial input. The Fibonacci recursion is easily
reduced to the following function

```clojure
(fn [[fb-1 fb-2]]
  [fb-2 (+ fb-1 fb-2)])
```

With an initial state `[0 1]`. After that gem, I decided to use a transducer for filtering and adding
the Fibonacci numbers, obtaining the same result as before! I mostly used a transducer just to flex ;).

### A note on Transducers

Transducers are a feature of Clojure that allow an abstract representation of composable algorithmic
transformations, _independent on the type of input_. See more in the 
[Clojure docs](https://clojure.org/reference/transducers). They can be composed using `comp`.

> In the simplest cases, transducers can be used in two ways:
> 1. With `transduce`. Usually when the input needs to be aggregated using a _reducing function_ (like addition).
> 2. With `eduction`. To generate a reducible/iterable from the input.

Some of the advantages of using transducers are

* No intermediate sequences are generated while applying composed transformations
* Are reusable in case the transformations need to happen across different entities
* Perfect when you need an immediate sequence of values

> IMPORTANT: Better use lazy sequences if you are going to work with infinite sequences, or not need an immediate
> result after the execution

Ohhh, and also, a cool feature is that a transducer can be used with `into`, for generating sequences too!